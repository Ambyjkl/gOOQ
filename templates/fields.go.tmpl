// THIS FILE WAS AUTOGENERATED - ANY EDITS TO THIS WILL BE LOST WHEN IT IS REGENERATED

{{ $preds := .predicates }}
{{ $funcs := .functions }}

package gooq

import (
	"time"

	"github.com/google/uuid"
	"gopkg.in/guregu/null.v3"

	"github.com/lumina-tech/lumina/apps/server/pkg/gooq/nullable"
)

type Functional interface {
{{ range $_, $f := $funcs }}
  {{ $f.Name }}({{ signifier $f }}) Field
{{ end }}
}

{{ range $_, $t := .types }}
func (s *selection) {{ $t.Prefix }}Field(name string) {{ $t.Prefix }}Field {
  return &{{ toLower $t.Prefix }}Field{name: name}
}
{{ end }}

/////

{{ range $_, $t := .types }}

type {{ toLower $t.Prefix }}Field struct {
  name string
  selection Selectable
  alias string
  fun FieldFunction
  filters []Condition
}

type {{ $t.Prefix }}Field interface {
  TableField
  {{ range $_, $p := $preds }}
  {{ $p.FieldFunction }}(value {{ $t.Literal }}) Condition
  {{ $p.JoinFunction }}(value {{ $t.Prefix }}Field) JoinCondition
  {{ end }}
  IsNull() Condition
  IsNotNull() Condition
  In(value []{{ $t.Literal }}) Condition
  NotIn(value []{{ $t.Literal }}) Condition
}

func (c *{{ toLower $t.Prefix }}Field) Function() FieldFunction {
  return FieldFunction{
    Name:  c.fun.Name,
    Expr:  c.fun.Expr,
    Args:  c.fun.Args,
    Child: c.fun.Child,
  }
}

func (c *{{ toLower $t.Prefix }}Field) fct(fun, expr string, args ...interface{}) Field {
  if &c.fun == nil {
    return &{{ toLower $t.Prefix }}Field{
      name:      c.name,
      selection: c.selection,
      fun:       FieldFunction{Name:fun, Expr:expr, Args: args},
    }
  } else {
    return &{{ toLower $t.Prefix }}Field{
      name:      c.name,
      selection: c.selection,
      fun:       FieldFunction{
        Name:  fun,
        Expr:  expr,
        Args:  args,
        Child: &FieldFunction{
          Name:  c.fun.Name,
          Expr:  c.fun.Expr,
          Args:  c.fun.Args,
          Child: c.fun.Child,
        },
      },
      filters: c.filters,
    }
  }
}

func (c *{{ toLower $t.Prefix }}Field) FilterWhere(filters ...Condition) Field {
  return &{{ toLower $t.Prefix }}Field{
    name: c.name,
    selection: c.selection,
    alias: c.alias,
    fun: FieldFunction{
      Name:  c.fun.Name,
      Expr:  c.fun.Expr,
      Args:  c.fun.Args,
      Child: c.fun.Child,
    },
    filters: filters,
  }
}

func (c *{{ toLower $t.Prefix }}Field) As(alias string) Field {
  return &{{ toLower $t.Prefix }}Field{
    name: c.name,
    selection: c.selection,
    alias: alias,
    fun: FieldFunction{
      Name:  c.fun.Name,
      Expr:  c.fun.Expr,
      Args:  c.fun.Args,
      Child: c.fun.Child,
    },
    filters: c.filters,
  }
}

func (c *{{ toLower $t.Prefix }}Field) Alias() string {
  return c.alias
}

func (c *{{ toLower $t.Prefix }}Field) MaybeAlias() string {
  if c.alias == "" {
    return c.name
  } else {
    return c.alias
  }
}

func (c *{{ toLower $t.Prefix }}Field) Name() string {
  return c.name
}

func (c *{{ toLower $t.Prefix }}Field) String() string {
  return renderFunction(c.name, c.Function())
}

func (c *{{ toLower $t.Prefix }}Field) Parent() Selectable {
  return c.selection
}

func (c *{{ toLower $t.Prefix }}Field) Filters() []Condition {
  return c.filters
}

// --

{{ range $_, $p := $preds }}

func (c *{{ toLower $t.Prefix }}Field) {{ $p.FieldFunction }}(pred {{ $t.Literal }}) Condition {
  return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: {{ $p.Predicate }}}
}

func (c *{{ toLower $t.Prefix }}Field) {{ $p.JoinFunction }}(pred {{ $t.Prefix }}Field) JoinCondition {
  return JoinCondition{Lhs: c, Rhs: pred, Predicate: {{ $p.Predicate }}}
}

{{ end }}

func (c *{{ toLower $t.Prefix }}Field) IsNull() Condition {
  return Condition{Binding: FieldBinding{Field: c}, Predicate: IsNullPredicate}
}

func (c *{{ toLower $t.Prefix }}Field) IsNotNull() Condition {
  return Condition{Binding: FieldBinding{Field: c}, Predicate: IsNotNullPredicate}
}

func (c *{{ toLower $t.Prefix }}Field) In(pred []{{ $t.Literal }}) Condition {
  return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: InPredicate}
}

func (c *{{ toLower $t.Prefix }}Field) NotIn(pred []{{ $t.Literal }}) Condition {
  return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: NotInPredicate}
}

// --

func {{ $t.Prefix }}(s Selectable, name string) {{ $t.Prefix }}Field {
  return &{{ toLower $t.Prefix }}Field{name: name, selection: s}
}

//////

{{ range $_, $f := $funcs }}
func (c *{{ toLower $t.Prefix }}Field) {{ $f.Name }}({{ signifier $f }}) Field {
  return c.fct("{{ $f.Name }}", "{{ $f.Expr }}"{{ injectifier $f }})
}
{{ end }}

{{ end }}
